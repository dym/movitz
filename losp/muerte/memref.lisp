;;;;------------------------------------------------------------------
;;;; 
;;;;    Copyright (C) 2001-2005, 
;;;;    Department of Computer Science, University of Tromso, Norway.
;;;; 
;;;;    For distribution policy, see the accompanying file COPYING.
;;;; 
;;;; Filename:      memref.lisp
;;;; Description:   Low-level memory access.
;;;; Author:        Frode Vatvedt Fjeld <frodef@acm.org>
;;;; Created at:    Tue Mar  6 21:25:49 2001
;;;;                
;;;; $Id: memref.lisp,v 1.52 2008/01/17 20:20:33 ffjeld Exp $
;;;;                
;;;;------------------------------------------------------------------

(require :muerte/typep)
(provide :muerte/memref)

(in-package muerte)

(eval-when (:compile-toplevel)
  (defun extract-constant-delta (form env)
    "Try to extract at compile-time an integer offset from form, repeatedly."
    (labels ((sub-extract-constant-delta (form)
	       "Try to extract at compile-time an integer offset from form."
	       (cond
		((movitz:movitz-constantp form env)
		 (let ((x (movitz:movitz-eval form env)))
		   (check-type x integer)
		   (values x 0)))
		((not (consp form))
		 (values 0 form))
		(t (case (car form)
		     (1+ (values 1 (second form)))
		     (1- (values -1 (second form)))
		     (+ (case (length form)
			  (1 (values 0 0))
			  (2 (values 0 (second form)))
			  (t (loop with x = 0 and f = nil for sub-form in (cdr form)
				 as sub-value = (when (movitz:movitz-constantp sub-form env)
						  (movitz:movitz-eval sub-form env))
				 do (if (integerp sub-value)
					(incf x sub-value)
				      (push sub-form f))
				 finally (return (values x (cons '+ (nreverse f))))))))
		     (t (values 0 form)))))))
      (multiple-value-bind (constant-term variable-term)
	  (sub-extract-constant-delta form)
	(if (= 0 constant-term)
	    (values 0 variable-term)
	  (multiple-value-bind (sub-constant-term sub-variable-term)
	      (extract-constant-delta variable-term env)
	    (values (+ constant-term sub-constant-term)
		    sub-variable-term)))))))

(define-compiler-macro memref (&whole form object offset
			       &key (index 0) (type :lisp) (localp nil) (endian :host)
				    (physicalp nil)
			       &environment env)
  (if (or (not (movitz:movitz-constantp type env))
	  (not (movitz:movitz-constantp localp env))
	  (not (movitz:movitz-constantp endian env))
	  (not (movitz:movitz-constantp physicalp env)))
      form
    (multiple-value-bind (constant-index index)
	(extract-constant-delta index env)
      (multiple-value-bind (constant-offset offset)
	  (extract-constant-delta offset env)
	(flet ((offset-by (element-size)
		 (+ constant-offset (* constant-index element-size))))
	  #+ignore
	  (warn "o: ~S, co: ~S, i: ~S, ci: ~S"
		offset constant-offset
		index constant-index)
	  (let ((type (movitz:movitz-eval type env))
		(physicalp (movitz:movitz-eval physicalp env))
		(prefixes (if (not physicalp)
			      ()
			      movitz:*compiler-physical-segment-prefix*)))
	    (when (and physicalp (member type '(:lisp :code-vector)))
	      (warn "(memref physicalp) unsupported for type ~S." type))
	    (case type
	      (:unsigned-byte8
	       (cond
		((and (eql 0 offset) (eql 0 index))
		 `(with-inline-assembly (:returns :untagged-fixnum-ecx :type (unsigned-byte 8))
		    (:compile-form (:result-mode :eax) ,object)
		    (,prefixes :movzxb (:eax ,(offset-by 1)) :ecx)))
		((eql 0 index)
		 (let ((object-var (gensym "memref-object-"))
		       (offset-var (gensym "memref-offset-")))
		   `(let ((,object-var ,object)
			  (,offset-var ,offset))
		      (with-inline-assembly (:returns :untagged-fixnum-ecx
						      :type (unsigned-byte 8))
			(:compile-two-forms (:eax :untagged-fixnum-ecx) ,object-var ,offset-var)
			;; (:sarl ,movitz:+movitz-fixnum-shift+ :ecx)
			(,prefixes :movzxb (:eax :ecx ,(offset-by 1)) :ecx)))))
		((eql 0 offset)
		 `(with-inline-assembly (:returns :untagged-fixnum-ecx :type (unsigned-byte 8))
		    (:compile-two-forms (:eax :untagged-fixnum-ecx) ,object ,index)
		    (,prefixes :movzxb (:eax :ecx ,(offset-by 1)) :ecx)))
		(t (let ((object-var (gensym "memref-object-")))
		     `(let ((,object-var ,object))
			(with-inline-assembly (:returns :untagged-fixnum-ecx :type (unsigned-byte 8))
			  (:compile-two-forms (:ecx :ebx) ,offset ,index)
			  (:load-lexical (:lexical-binding ,object-var) :eax)
			  (:addl :ebx :ecx) ; index += offset
			  (:sarl ,movitz::+movitz-fixnum-shift+ :ecx)
			  (,prefixes :movzxb (:eax :ecx ,(offset-by 1)) :ecx)))))))
	      (:unsigned-byte16
	       (let* ((endian (ecase (movitz:movitz-eval endian env)
				((:host :little) :little)
				(:big :big)))
		      (endian-fix-ecx (ecase endian
					(:little nil)
					(:big `((:xchgb :cl :ch))))))
		 (cond
		  ((and (eql 0 offset) (eql 0 index))
		   `(with-inline-assembly (:returns :untagged-fixnum-ecx
						    :type (unsigned-byte 16))
		      (:compile-form (:result-mode :eax) ,object)
		      (,prefixes :movzxw (:eax ,(offset-by 2)) :ecx)
		      ,@endian-fix-ecx))
		  ((eql 0 index)
		   (let ((object-var (gensym "memref-object-"))
			 (offset-var (gensym "memref-offset-")))
		     `(let ((,object-var ,object)
			    (,offset-var ,offset))
			(with-inline-assembly (:returns :untagged-fixnum-ecx
							:type (unsigned-byte 16))
			  (:compile-two-forms (:eax :ecx) ,object-var ,offset-var)
			  (:sarl ,movitz:+movitz-fixnum-shift+ :ecx)
			  (,prefixes :movzxw (:eax :ecx ,(offset-by 2)) :ecx)
			  ,@endian-fix-ecx))))
		  ((eql 0 offset)
		   (let ((object-var (gensym "memref-object-"))
			 (index-var (gensym "memref-index-")))
		     `(let ((,object-var ,object)
			    (,index-var ,index))
			(with-inline-assembly (:returns :untagged-fixnum-ecx
							:type (unsigned-byte 16))
			  (:compile-two-forms (:eax :ecx) ,object-var ,index-var)
			  (:sarl ,(1- movitz:+movitz-fixnum-shift+) :ecx)
			  (,prefixes :movzxw (:eax :ecx ,(offset-by 2)) :ecx)
			  ,@endian-fix-ecx))))
		  (t (let ((object-var (gensym "memref-object-"))
			   (offset-var (gensym "memref-offset-"))
			   (index-var (gensym "memref-index-")))
		       `(let ((,object-var ,object)
			      (,offset-var ,offset)
			      (,index-var ,index))
			  (with-inline-assembly (:returns :untagged-fixnum-ecx
							  :type (unsigned-byte 16))
			    (:compile-two-forms (:ecx :ebx) ,offset-var ,index-var)
			    (:leal (:ecx (:ebx 2)) :ecx)
			    (:load-lexical (:lexical-binding ,object-var) :eax)
			    (:sarl ,movitz::+movitz-fixnum-shift+ :ecx)
			    (,prefixes :movzxw (:eax :ecx ,(offset-by 2)) :ecx)
			    ,@endian-fix-ecx)))))))
	      (:unsigned-byte14
	       (cond
		((and (eq 0 offset) (eq 0 index))
		 `(with-inline-assembly (:returns :ecx :type (unsigned-byte 14))
		    (:compile-form (:result-mode :eax) ,object)
		    (,prefixes :movzxw (:eax ,(offset-by 2)) :ecx)
		    (:testb ,movitz:+movitz-fixnum-zmask+ :cl)
		    (:jnz '(:sub-program () (:int 63)))))
		((eq 0 offset)
		 (let ((object-var (gensym "memref-object-"))
		       (index-var (gensym "memref-index-")))
		   `(let ((,object-var ,object)
			  (,index-var ,index))
		      (with-inline-assembly (:returns :ecx)
			(:compile-two-forms (:eax :ecx) ,object-var ,index-var)
			(:sarl ,(1- movitz:+movitz-fixnum-shift+) :ecx)
			(,prefixes :movzxw (:eax :ecx ,(offset-by 2)) :ecx)
			(:testb ,movitz:+movitz-fixnum-zmask+ :cl)
			(:jnz '(:sub-program () (:int 63)))))))
		(t (let ((object-var (gensym "memref-object-"))
			 (offset-var (gensym "memref-offset-"))
			 (index-var (gensym "memref-index-")))
		     `(let ((,object-var ,object)
			    (,offset-var ,offset)
			    (,index-var ,index))
			(with-inline-assembly (:returns :ecx)
			  (:compile-two-forms (:ecx :ebx) ,offset-var ,index-var)
			  (:leal (:ecx (:ebx 2)) :ecx)
			  (:load-lexical (:lexical-binding ,object-var) :eax)
			  (:sarl ,movitz::+movitz-fixnum-shift+ :ecx)
			  (,prefixes :movzxw (:eax :ecx ,(offset-by 2)) :ecx)
			  (:testb ,movitz:+movitz-fixnum-shift+ :cl)
			  (:jnz '(:sub-program () (:int 63)))))))))
	      (:unsigned-byte29+3
	       ;; Two values: the 29 upper bits as unsigned integer,
	       ;; and secondly the lower 3 bits as unsigned.
	       (assert (= 2 movitz::+movitz-fixnum-shift+))
	       `(with-inline-assembly (:returns :multiple-values)
		  (:compile-form (:result-mode :push) ,object)
		  (:compile-two-forms (:ecx :ebx) ,offset ,index)
		  (:sarl ,movitz::+movitz-fixnum-shift+ :ecx)
		  (:addl :ebx :ecx)
		  (:popl :eax)		; object
		  (,prefixes :movl (:eax :ecx ,(offset-by 4)) :ecx)
		  (:leal ((:ecx 4)) :ebx)
		  (:shrl 1 :ecx)
		  (:andl #b11100 :ebx)
		  (:andl -4 :ecx)
		  (:movl :ecx :eax)
		  (:movl 2 :ecx)
		  (:stc)))
	      (:signed-byte30+2
	       ;; Two values: the 30 upper bits as signed integer,
	       ;; and secondly the lower 2 bits as unsigned.
	       (assert (= 2 movitz::+movitz-fixnum-shift+))
	       (let ((fix-ecx `((:leal ((:ecx 4)) :ebx)
				(:andl -4 :ecx)
				(:andl #b1100 :ebx)
				(:movl :ecx :eax)
				(:movl 2 :ecx)
				(:stc))))
		 (cond
		  ((and (eq 0 offset) (eq 0 index))
		   `(with-inline-assembly (:returns :multiple-values)
		      (:compile-form (:result-mode :eax) ,object)
		      (,prefixes :movl (:eax ,(offset-by 4)) :ecx)
		      ,@fix-ecx))
		  ((eq 0 offset)
		   `(with-inline-assembly (:returns :multiple-values)
		      (:compile-two-forms (:eax :ecx) ,object ,index)
		      (,prefixes :movl (:eax :ecx ,(offset-by 4)) :ecx)
		      ,@fix-ecx))
		  (t (let ((object-var (gensym "memref-object-")))
		       `(let ((,object-var ,object))
			  (with-inline-assembly (:returns :multiple-values)
			    (:compile-two-forms (:ecx :ebx) ,offset ,index)
			    (:sarl ,movitz::+movitz-fixnum-shift+ :ecx)
			    (:load-lexical (:lexical-binding ,object-var) :eax)
			    (:addl :ebx :ecx)
			    (:movl (:eax :ecx ,(offset-by 4)) :ecx)
			    ,@fix-ecx))))))
	       #+ignore
	       `(with-inline-assembly (:returns :multiple-values)
		  (:compile-form (:result-mode :push) ,object)
		  (:compile-two-forms (:ecx :ebx) ,offset ,index)
		  (:sarl ,movitz::+movitz-fixnum-shift+ :ecx)
		  (:addl :ebx :ecx)
		  (:popl :eax)		; object
		  (:movl (:eax :ecx ,(offset-by 4)) :ecx)
		  (:leal ((:ecx 4)) :ebx)
		  (:andl #b1100 :ebx)
		  (:andl -4 :ecx)
		  (:movl :ecx :eax)
		  (:movl 2 :ecx)
		  (:stc)))
	      (:character
	       (when (eq 0 index) (warn "memref zero char index!"))
	       (cond
		((eq 0 offset)
		 `(with-inline-assembly (:returns :eax)
		    (:compile-two-forms (:ebx :ecx) ,object ,index)
		    (:xorl :eax :eax)
		    (:movb ,(movitz:tag :character) :al)
		    (:sarl ,movitz::+movitz-fixnum-shift+ :ecx) ; scale index
		    (,prefixes :movb (:ebx :ecx ,(offset-by 1)) :ah)))
		(t (let ((object-var (gensym "memref-object-")))
		     `(let ((,object-var ,object))
			(with-inline-assembly (:returns :eax)
			  (:compile-two-forms (:ecx :ebx) ,offset ,index)
			  (:addl :ebx :ecx)
			  (:xorl :eax :eax)
			  (:movb ,(movitz:tag :character) :al)
			  (:load-lexical (:lexical-binding ,object-var) :ebx)
			  (:sarl ,movitz::+movitz-fixnum-shift+ :ecx) ; scale offset+index
			  (,prefixes :movb (:ebx :ecx ,(offset-by 1)) :ah)))))))
	      (:location
	       (assert (= 4 movitz::+movitz-fixnum-factor+))
	       (cond
		((and (eq 0 offset) (eq 0 index))
		 `(with-inline-assembly (:returns :ecx :type (signed-byte 30))
		    (:compile-form (:result-mode :eax) ,object)
		    (,prefixes :movl (:eax ,(offset-by 4)) :ecx)
		    (:andl -4 :ecx)))
		((eq 0 offset)
		 `(with-inline-assembly (:returns :ecx :type (signed-byte 30))
		    (:compile-two-forms (:eax :ecx) ,object ,index)
		    (,prefixes :movl (:eax :ecx ,(offset-by 4)) :ecx)
		    (:andl -4 :ecx)))
		(t (let ((object-var (gensym "memref-object-")))
		     `(let ((,object-var ,object))
			(with-inline-assembly (:returns :ecx :type (signed-byte 30))
			  (:compile-two-forms (:ecx :ebx) ,offset ,index)
			  (:sarl ,movitz::+movitz-fixnum-shift+ :ecx)
			  (:load-lexical (:lexical-binding ,object-var) :eax)
			  (:addl :ebx :ecx)
			  (,prefixes :movl (:eax :ecx ,(offset-by 4)) :ecx)
			  (:andl -4 :ecx)))))))
	      (:tag
	       (assert (= 4 movitz::+movitz-fixnum-factor+))
	       (cond
		((and (eq 0 offset) (eq 0 index))
		 `(with-inline-assembly (:returns :untagged-fixnum-ecx :type (unsigned-byte 3))
		    (:compile-form (:result-mode :eax) ,object)
		    (,prefixes :movl (:eax ,(offset-by 4)) :ecx)
		    (:andl 7 :ecx)))
		((eq 0 offset)
		 `(with-inline-assembly (:returns :untagged-fixnum-ecx :type (unsigned-byte 3))
		    (:compile-two-forms (:eax :ecx) ,object ,index)
		    (,prefixes :movl (:eax :ecx ,(offset-by 4)) :ecx)
		    (:andl 7 :ecx)))
		(t (let ((object-var (gensym "memref-object-")))
		     `(let ((,object-var ,object))
			(with-inline-assembly (:returns :untagged-fixnum-ecx :type (unsigned-byte 3))
			  (:compile-two-forms (:ecx :ebx) ,offset ,index)
			  (:sarl ,movitz::+movitz-fixnum-shift+ :ecx)
			  (:load-lexical (:lexical-binding ,object-var) :eax)
			  (:addl :ebx :ecx)
			  (,prefixes :movl (:eax :ecx ,(offset-by 4)) :ecx)
			  (:andl 7 :ecx)))))))
	      (:unsigned-byte32
	       (let ((fix-endian (ecase (movitz:movitz-eval endian env)
				   ((:host :little) ())
				   (:big `((:bswap :ecx))))))
		 (assert (= 4 movitz::+movitz-fixnum-factor+))
		 (cond
		   ((and (eq 0 offset) (eq 0 index))
		    `(with-inline-assembly (:returns :untagged-fixnum-ecx
						     :type (unsigned-byte 32))
		       (:compile-form (:result-mode :eax) ,object)
		       (,prefixes :movl (:eax ,(offset-by 4)) :ecx)
		       ,@fix-endian))
		   ((eq 0 offset)
		    `(with-inline-assembly (:returns :untagged-fixnum-ecx
						     :type (unsigned-byte 32))
		       (:compile-two-forms (:eax :ecx) ,object ,index)
		       (,prefixes :movl (:eax :ecx ,(offset-by 4)) :ecx)
		       ,@fix-endian))
		   (t (let ((object-var (gensym "memref-object-")))
			`(let ((,object-var ,object))
			   (with-inline-assembly (:returns :untagged-fixnum-ecx
							   :type (unsigned-byte 32))
			     (:compile-two-forms (:ecx :ebx) ,offset ,index)
			     (:sarl ,movitz::+movitz-fixnum-shift+ :ecx)
			     (:load-lexical (:lexical-binding ,object-var) :eax)
			     (:addl :ebx :ecx)
			     (,prefixes :movl (:eax :ecx ,(offset-by 4)) :ecx)
			     ,@fix-endian)))))))
	      (:lisp
	       (let* ((localp (movitz:movitz-eval localp env))
		      (prefixes (if localp
				    nil
				  movitz:*compiler-nonlocal-lispval-read-segment-prefix*)))
		 (cond
		  ((and (eql 0 index) (eql 0 offset))
		   `(with-inline-assembly (:returns :register)
		      (:compile-form (:result-mode :register) ,object)
		      (,prefixes :movl ((:result-register) ,(offset-by 4)) (:result-register))))
		  ((eql 0 offset)
		   `(with-inline-assembly (:returns :eax)
		      (:compile-two-forms (:eax :ecx) ,object ,index)
		      ,@(when (cl:plusp (cl:- movitz::+movitz-fixnum-shift+ 2))
			  `((:sarl ,(cl:- movitz::+movitz-fixnum-shift+ 2)) :ecx))
		      (,prefixes :movl (:eax :ecx ,(offset-by 4)) :eax)))
		  ((eql 0 index)
		   `(with-inline-assembly (:returns :eax)
		      (:compile-two-forms (:eax :untagged-fixnum-ecx) ,object ,offset)
		      (,prefixes :movl (:eax :ecx ,(offset-by 4)) :eax)))
		  (t (assert (not (movitz:movitz-constantp offset env)))
		     (assert (not (movitz:movitz-constantp index env)))
		     (let ((object-var (gensym "memref-object-")))
		       (assert (= 4 movitz:+movitz-fixnum-factor+))
		       `(let ((,object-var ,object))
			  (with-inline-assembly (:returns :eax)
			    (:compile-two-forms (:ecx :ebx) ,offset ,index)
			    (:sarl ,movitz:+movitz-fixnum-shift+ :ecx)
			    (:load-lexical (:lexical-binding ,object-var) :eax)
			    (:addl :ebx :ecx)
			    (,prefixes :movl (:eax :ecx ,(offset-by 4)) :eax))))))))
	      (:code-vector
	       ;; A code-vector is like a normal lisp word pointer,
	       ;; except it's known to point to a code-vector, and
	       ;; the pointer value is offset by 2. The trick is to
	       ;; perform this pointer arithmetics while never
	       ;; keeping a non-lisp-word pointer in a register.
	       (cond
		((and (eql 0 index) (eql 0 offset))
		 `(with-inline-assembly (:returns :eax)
		    (:compile-form (:result-mode :ebx) ,object)
		    (:movl ,(ldb (byte 32 0) (- movitz:+code-vector-word-offset+)) :eax)
		    (:addl (:ebx ,(offset-by 4)) :eax)))
		((eql 0 offset)
		 `(with-inline-assembly (:returns :eax)
		    (:compile-two-forms (:ebx :ecx) ,object ,index)
		    ,@(when (cl:plusp (cl:- movitz::+movitz-fixnum-shift+ 2))
			`((:sarl ,(cl:- movitz::+movitz-fixnum-shift+ 2)) :ecx))
		    (:movl ,(ldb (byte 32 0) (- movitz:+code-vector-word-offset+)) :eax)
		    (:addl (:ebx :ecx ,(offset-by 4)) :eax)))
		((eql 0 index)
		 `(with-inline-assembly (:returns :eax)
		    (:compile-two-forms (:ebx :untagged-fixnum-ecx) ,object ,offset)
		    (:movl ,(ldb (byte 32 0) (- movitz:+code-vector-word-offset+)) :eax)
		    (:addl (:ebx :ecx ,(offset-by 4)) :eax)))
		(t (let ((object-var (gensym "memref-object-"))
			 (offset-var (gensym "memref-offset-"))
			 (index-var (gensym "memref-index-")))
		     `(let ((,object-var ,object)
			    (,offset-var ,offset)
			    (,index-var ,index))
			(with-inline-assembly (:returns :eax)
			  (:load-lexical (:lexical-binding ,offset-var) :untagged-fixnum-ecx)
			  (:load-lexical (:lexical-binding ,object-var) :ebx)
			  (:load-lexical (:lexical-binding ,index-var) :edx)
			  (:addl :edx :ecx)
			  (:movl ,(ldb (byte 32 0) (- movitz:+code-vector-word-offset+)) :eax)
			  (:addl (:ebx :ecx ,(offset-by 4)) :eax)))))
		#+ignore
		(t (error "variable memref type :code-vector not implemented."))
		#+ignore
		(t (assert (not (movitz:movitz-constantp offset env)))
		   (assert (not (movitz:movitz-constantp index env)))
		   (let ((object-var (gensym "memref-object-")))
		     (assert (= 4 movitz:+movitz-fixnum-factor+))
		     `(let ((,object-var ,object))
			(with-inline-assembly (:returns :eax)
			  (:compile-two-forms (:ecx :ebx) ,offset ,index)
			  (:sarl ,movitz:+movitz-fixnum-shift+ :ecx)
			  (:load-lexical (:lexical-binding ,object-var) :eax)
			  (:addl :ebx :ecx)
			  (:movl (:eax :ecx ,(offset-by 4)) :eax)))))))
	      (t (error "Unknown memref type: ~S" (movitz:movitz-eval type nil nil))
		 form))))))))

(defun memref (object offset &key (index 0) (type :lisp) localp (endian :host) physicalp)
  (case type
    (:lisp
     (if localp
	 (memref object offset :index index :localp t)
	 (memref object offset :index index :localp nil)))
    (:code-vector
     (memref object offset :index index :type :code-vector))
    (t (macrolet
	   ((do-memref (physicalp)
	      `(ecase type
	    
		 (:unsigned-byte32
		  (memref object offset :index index :type :unsigned-byte32 :physicalp ,physicalp))
		 (:character
		  (memref object offset :index  index :type :character :physicalp ,physicalp))
		 (:unsigned-byte8
		  (memref object offset :index index :type :unsigned-byte8 :physicalp ,physicalp))
		 (:location
		  (memref object offset :index index :type :location :physicalp ,physicalp))
		 (:unsigned-byte16
		  (ecase endian
		    ((:host :little)
		     (memref object offset :index index :type :unsigned-byte16 :endian :little :physicalp ,physicalp))
		    ((:big)
		     (memref object offset :index index :type :unsigned-byte16 :endian :big :physicalp ,physicalp))))
	    
		 (:unsigned-byte14
		  (memref object offset :index index :type :unsigned-byte14 :physicalp ,physicalp))
		 (:signed-byte30+2
		  (memref object offset :index index :type :signed-byte30+2 :physicalp ,physicalp))
		 (:unsigned-byte29+3
		  (memref object offset :index index :type :unsigned-byte29+3 :physicalp ,physicalp)))))
	 (if physicalp
	     (do-memref t)
	     (do-memref nil))))))

(define-compiler-macro (setf memref)
    (&whole form &environment env value object offset
	    &key (index 0) (type :lisp) (localp nil) (endian :host) (physicalp nil))
  (if (or (not (movitz:movitz-constantp type env))
	  (not (movitz:movitz-constantp localp env))
	  (not (movitz:movitz-constantp endian env))
	  (not (movitz:movitz-constantp physicalp env)))
      form
      (multiple-value-bind (constant-index xindex)
	  (extract-constant-delta index env)
	(multiple-value-bind (constant-offset xoffset)
	    (extract-constant-delta offset env)
	  (flet ((offset-by (element-size)
		   (+ constant-offset (* constant-index element-size))))
	    (let* ((physicalp (movitz::eval-form physicalp env))
		   (prefixes (if (not physicalp)
				 ()
				 movitz:*compiler-physical-segment-prefix*)))
	      (case (movitz::movitz-eval type env)
		(:character
		 (cond
		   ((and (movitz:movitz-constantp value env)
			 (movitz:movitz-constantp offset env)
			 (movitz:movitz-constantp index env))
		    (let ((value (movitz:movitz-eval value env)))
		      (check-type value movitz::movitz-character)
		      `(progn
			 (with-inline-assembly (:returns :nothing)
			   (:compile-form (:result-mode :ebx) ,object)
			   (,prefixes :movb ,(movitz:movitz-intern value)
				      (:ebx ,(+ (movitz:movitz-eval offset env)
						(* 1 (movitz:movitz-eval index env))))))
			 ,value)))
		   ((and (movitz:movitz-constantp offset env)
			 (movitz:movitz-constantp index env))
		    `(with-inline-assembly (:returns :eax)
		       (:compile-two-forms (:eax :ebx) ,value ,object)
		       (:movb :ah (:ebx ,(+ (movitz:movitz-eval offset env)
					    (* 1 (movitz:movitz-eval index env)))))))
		   ((movitz:movitz-constantp offset env)
		    (let ((value-var (gensym "memref-value-")))
		      `(let ((,value-var ,value)) 
			 (with-inline-assembly (:returns :eax)
			   (:compile-two-forms (:ebx :untagged-fixnum-ecx) ,object ,index)
			   (:load-lexical (:lexical-binding ,value-var) :eax)
			   (:movb :ah (:ebx :ecx ,(+ (movitz:movitz-eval offset env))))))))
		   (t (let ((object-var (gensym "memref-object-"))
			    (offset-var (gensym "memref-offset-")))
			`(let ((,object-var ,object) (,offset-var ,offset))
			   (with-inline-assembly (:returns :nothing)
			     (:compile-two-forms (:ecx :eax) ,index ,value)
			     (:load-lexical (:lexical-binding ,offset-var) :ebx)
			     (:addl :ebx :ecx)
			     (:sarl ,movitz::+movitz-fixnum-shift+ :ecx)
			     (:load-lexical (:lexical-binding ,object-var) :ebx)
			     (:movb :ah (:ebx :ecx))))))))
		(:unsigned-byte32
		 (let ((endian (ecase (movitz:movitz-eval endian env)
				 ((:host :little) :little)
				 (:big :big))))
		   (assert (= 4 movitz::+movitz-fixnum-factor+))
		   (cond
		     ((and (movitz:movitz-constantp value env)
			   (movitz:movitz-constantp offset env)
			   (movitz:movitz-constantp index env))
		      (let ((value (movitz:movitz-eval value env)))
			(check-type value (unsigned-byte 32))
			`(progn
			   (with-inline-assembly (:returns :nothing)
			     (:compile-form (:result-mode :ebx) ,object)
			     (,prefixes :movl ,value (:ebx ,(+ (movitz:movitz-eval offset env)
							       (* 4 (movitz:movitz-eval index env))))))
			   ,value)))
		     ((and (movitz:movitz-constantp offset env)
			   (movitz:movitz-constantp index env))
		      `(with-inline-assembly (:returns :untagged-fixnum-ecx)
			 (:compile-two-forms (:untagged-fixnum-ecx :ebx) ,value ,object)
			 ,@(when (eq endian :big)
				 `((:bswap :ecx)))
			 (,prefixes :movl :ecx (:ebx ,(+ (movitz:movitz-eval offset env)
							 (* 4 (movitz:movitz-eval index env)))))))
		     ((and (movitz:movitz-constantp offset env)
			   (movitz:movitz-constantp value env))
		      (let ((value (movitz:movitz-eval value env)))
			(check-type value (unsigned-byte 32))
			(let ((value (ecase endian
				       (:little value)
				       (:big (logior (ash (ldb (byte 8 0) value) 24)
						     (ash (ldb (byte 8 8) value) 16)
						     (ash (ldb (byte 8 16) value) 8)
						     (ash (ldb (byte 8 24) value) 0))))))
			  `(progn
			     (with-inline-assembly (:returns :nothing)
			       (:compile-two-forms (:ecx :ebx) ,index ,object)
			       (,prefixes :movl ,value (:ebx :ecx ,(movitz:movitz-eval offset env))))
			     ,value))))
		     ((movitz:movitz-constantp offset env)
		      (let ((value-var (gensym "memref-value-"))
			    (object-var (gensym "memref-object-"))
			    (index-var (gensym "memref-index-")))
			`(let ((,value-var ,value)
			       (,object-var ,object)
			       (,index-var ,index))
			   (with-inline-assembly (:returns :untagged-fixnum-ecx)
			     (:load-lexical (:lexical-binding ,value-var) :untagged-fixnum-ecx)
			     (:compile-two-forms (:ebx :eax) ,object-var ,index-var)
			     ,@(when (eq endian :big)
				     `((:bswap :ecx)))
			     (,prefixes :movl :ecx (:eax :ebx ,(movitz:movitz-eval offset env)))))))
		     (t (let ((value-var (gensym "memref-value-"))
			      (object-var (gensym "memref-object-"))
			      (offset-var (gensym "memref-offset-"))
			      (index-var (gensym "memref-index-")))
			  (assert (= 4 movitz:+movitz-fixnum-factor+))
			  `(let ((,value-var ,value)
				 (,object-var ,object)
				 (,offset-var ,offset)
				 (,index-var ,index))
			     (with-inline-assembly (:returns :untagged-fixnum-ecx)
			       (:compile-two-forms (:eax :edx) ,index-var ,offset-var)
			       (:load-lexical (:lexical-binding ,value-var) :untagged-fixnum-ecx)
			       (:load-lexical (:lexical-binding ,object-var) :ebx)
			       ,@(when (eq endian :big)
				       `((:bswap :ecx)))
			       (:std)
			       (:sarl ,movitz::+movitz-fixnum-shift+ :edx)
			       (:addl :eax :edx) ; EDX = offset+index
			       (,prefixes :movl :ecx (:ebx :edx))
			       (:movl :edi :edx)
			       (:cld))))))))
		(:unsigned-byte16
		 (let ((endian (ecase (movitz:movitz-eval endian env)
				 ((:host :little) :little)
				 (:big :big))))
		   (cond
		     ((and (movitz:movitz-constantp value env)
			   (movitz:movitz-constantp offset env)
			   (movitz:movitz-constantp index env))
		      (let* ((host-value (movitz:movitz-eval value env))
			     (value (ecase endian
				      (:little host-value)
				      (:big (dpb (ldb (byte 8 0) host-value)
						 (byte 8 8)
						 (ldb (byte 8 8) host-value))))))
			(check-type value (unsigned-byte 16))
			`(progn
			   (with-inline-assembly (:returns :nothing)
			     (:compile-form (:result-mode :ebx) ,object)
			     (,prefixes :movw ,value (:ebx ,(+ (movitz:movitz-eval offset env)
							       (* 2 (movitz:movitz-eval index env))))))
			   ,value)))
		     ((and (movitz:movitz-constantp offset env)
			   (movitz:movitz-constantp index env))
		      `(with-inline-assembly (:returns :untagged-fixnum-ecx)
			 (:compile-two-forms (:untagged-fixnum-ecx :ebx) ,value ,object)
			 ,@(ecase endian
				  (:little nil)
				  (:big `((:xchg :cl :ch))))
			 (,prefixes :movw :cx (:ebx ,(+ (movitz:movitz-eval offset env)
							(* 2 (movitz:movitz-eval index env)))))))
		     ((and (movitz:movitz-constantp offset env)
			   (movitz:movitz-constantp value env))
		      (let ((value (movitz:movitz-eval value env))
			    (index-var (gensym "memref-index-"))
			    (object-var (gensym "memref-object-")))
			(check-type value (unsigned-byte 16))
			`(let ((,object-var ,object)
			       (,index-var ,index))
			   (with-inline-assembly (:returns :nothing)
			     (:compile-two-forms (:ecx :ebx) ,index-var ,object-var)
			     (:sarl ,(1- movitz:+movitz-fixnum-shift+) :ecx)
			     (,prefixes :movw ,value (:ebx :ecx ,(movitz:movitz-eval offset env))))
			   ,value)))
		     ((movitz:movitz-constantp offset env)
		      (let ((value-var (gensym "memref-value-"))
			    (index-var (gensym "memref-index-"))
			    (object-var (gensym "memref-object-")))
			(if (<= 16 movitz:*compiler-allow-untagged-word-bits*)
			    `(let ((,value-var ,value)
				   (,object-var ,object)
				   (,index-var ,index))
			       (with-inline-assembly (:returns :untagged-fixnum-eax)
				 (:compile-two-forms (:ebx :ecx) ,object-var ,index-var)
				 (:load-lexical (:lexical-binding ,value-var) :untagged-fixnum-eax)
				 (:sarl ,(1- movitz:+movitz-fixnum-shift+) :ecx)
				 (:movw :ax (:ebx :ecx  ,(movitz:movitz-eval offset env)))))
			    `(let ((,value-var ,value)
				   (,object-var ,object)
				   (,index-var ,index))
			       (with-inline-assembly (:returns :nothing)
				 (:compile-two-forms (:ebx :ecx) ,object-var ,index-var)
				 (:load-lexical (:lexical-binding ,value-var) :eax)
				 (:sarl ,(1- movitz:+movitz-fixnum-shift+) :ecx)
				 (:movl :edi :edx)
				 (:std)
				 (:shrl ,movitz:+movitz-fixnum-shift+ :eax)
				 ,@(ecase endian
					  (:little nil)
					  (:big `((:xchgb :al :ah))))
				 (,prefixes :movw :ax (:ebx :ecx ,(movitz:movitz-eval offset env)))
				 (:movl :edi :eax)
				 (:cld))
			       ,value-var))))
		     (t (let ((value-var (gensym "memref-value-"))
			      (object-var (gensym "memref-object-"))
			      (offset-var (gensym "memref-offset-"))
			      (index-var (gensym "memref-index-")))
			  (if (<= 16 movitz:*compiler-allow-untagged-word-bits*)
			      `(let ((,value-var ,value)
				     (,object-var ,object)
				     (,offset-var ,offset)
				     (,index-var ,index))
				 (with-inline-assembly (:returns :untagged-fixnum-eax)
				   (:compile-two-forms (:ebx :ecx) ,offset-var ,index-var)
				   (:load-lexical (:lexical-binding ,value-var) :eax)
				   (:andl ,(* movitz:+movitz-fixnum-factor+ #xffff) :eax)
				   (:leal (:ebx (:ecx 2)) :ecx)
				   (:shrl ,movitz:+movitz-fixnum-shift+ :eax)
				   (:sarl ,movitz:+movitz-fixnum-shift+ :ecx)
				   (:load-lexical (:lexical-binding ,object-var) :ebx)
				   (,prefixes :movw :ax (:ebx :ecx))))
			      `(let ((,value-var ,value)
				     (,object-var ,object)
				     (,offset-var ,offset)
				     (,index-var ,index))
				 (with-inline-assembly (:returns :nothing)
				   (:compile-two-forms (:ebx :ecx) ,offset-var ,index-var)
				   (:load-lexical (:lexical-binding ,value-var) :eax)
				   (:leal (:ebx (:ecx 2)) :ecx)
				   (:sarl ,movitz:+movitz-fixnum-shift+ :ecx)
				   (:load-lexical (:lexical-binding ,object-var) :ebx)
				   (:std)
				   (:shrl ,movitz:+movitz-fixnum-shift+ :eax)
				   ,@(ecase endian
					    (:little nil)
					    (:big `((:xchgb :al :ah))))
				   (,prefixes :movw :ax (:ebx :ecx))
				   (:shll ,movitz:+movitz-fixnum-shift+ :eax)
				   (:movl :edi :edx)
				   (:cld))
				 ,value-var)))))))
		(:unsigned-byte8
		 (cond
		   ((and (movitz:movitz-constantp value env)
			 (eql 0 xoffset)
			 (eql 0 xindex))
		    (let ((value (movitz:movitz-eval value env)))
		      (check-type value (unsigned-byte 8))
		      `(progn
			 (with-inline-assembly (:returns :nothing)
			   (:compile-form (:result-mode :ebx) ,object)
			   (,prefixes :movb ,value (:ebx ,(offset-by 1))))
			 ,value)))
		   ((eql 0 xindex)
		    (let ((value-var (gensym "memref-value-"))
			  (object-var (gensym "memref-object-"))
			  (offset-var (gensym "memref-offset-")))
		      `(let ((,value-var ,value)
			     (,object-var ,object)
			     (,offset-var ,xoffset))
			 (with-inline-assembly (:returns :nothing)
			   (:load-lexical (:lexical-binding ,offset-var) :untagged-fixnum-ecx)
			   (:load-lexical (:lexical-binding ,value-var) :eax)
			   (:load-lexical (:lexical-binding ,object-var) :ebx)
			   (:shll ,(- 8 movitz:+movitz-fixnum-shift+) :eax)
			   (,prefixes :movb :ah (:ebx :ecx ,(offset-by 1))))
			 ,value-var)))
		   ((and (eql 0 xoffset) (eql 0 xindex))
		    `(with-inline-assembly (:returns :untagged-fixnum-ecx)
		       (:compile-two-forms (:untagged-fixnum-ecx :ebx) ,value ,object)
		       (:movb :cl (:ebx ,(offset-by 1)))))
		   ((and (movitz:movitz-constantp offset env)
			 (movitz:movitz-constantp value env))
		    (let ((value (movitz:movitz-eval value env)))
		      (check-type value (unsigned-byte 8))
		      `(progn
			 (with-inline-assembly (:returns :untagged-fixnum-ecx)
			   (:compile-two-forms (:eax :ecx) ,object ,index)
			   (:sarl ,movitz:+movitz-fixnum-shift+ :ecx)
			   (,prefixes :movb ,value (:eax :ecx ,(movitz:movitz-eval offset env))))
			 value)))
		   ((movitz:movitz-constantp offset env)
		    (let ((value-var (gensym "memref-value-")))
		      `(let ((,value-var ,value))
			 (with-inline-assembly (:returns :nothing)
			   (:compile-two-forms (:ebx :ecx) ,object ,index)
			   (:load-lexical (:lexical-binding ,value-var) :eax)
			   (:sarl ,movitz:+movitz-fixnum-shift+ :ecx)
			   (:shll ,(- 8 movitz:+movitz-fixnum-shift+) :eax) ; value into :AH
			   (,prefixes :movb :ah (:ebx :ecx ,(movitz:movitz-eval offset env))))
			 ,value-var)))
		   (t (let ((value-var (gensym "memref-value-"))
			    (object-var (gensym "memref-object-")))
			`(let ((,value-var ,value) (,object-var ,object))
			   (with-inline-assembly (:returns :nothing)
			     (:compile-two-forms (:ebx :ecx) ,offset ,index)
			     (:load-lexical (:lexical-binding ,value-var) :eax)
			     (:addl :ebx :ecx)
			     (:load-lexical (:lexical-binding ,object-var) :ebx) ; value into :AH
			     (:shll ,(- 8 movitz:+movitz-fixnum-shift+) :eax)
			     (:sarl ,movitz::+movitz-fixnum-shift+ :ecx)
			     (,prefixes :movb :ah (:ebx :ecx)))
			   ,value-var)))))
		(:unsigned-byte14
		 (cond
		   ((and (movitz:movitz-constantp offset env)
			 (movitz:movitz-constantp index env))
		    `(with-inline-assembly (:returns :eax)
		       (:compile-two-forms (:eax :ebx) ,value ,object)
		       (:andl ,(mask-field (byte 14 2) -1) :eax)
		       (,prefixes :movw :ax (:ebx ,(+ (movitz:movitz-eval offset env)
						      (* 4 (movitz:movitz-eval index env)))))))
		   ((movitz:movitz-constantp offset env)
		    (let ((value-var (gensym "memref-value-")))
		      `(let ((,value-var ,value))
			 (with-inline-assembly (:returns :eax)
			   (:compile-two-forms (:ebx :ecx) ,object ,index)
			   (:load-lexical (:lexical-binding ,value-var) :eax)
			   ,@(when (plusp (- movitz:+movitz-fixnum-shift+ 2))
				   `((:sarl ,(- movitz:+movitz-fixnum-shift+ 2)) :ecx))
			   (:andl ,(mask-field (byte 14 2) -1) :eax)
			   (,prefixes :movw :ax (:ebx :ecx ,(movitz:movitz-eval offset env)))))))
		   (t (let ((value-var (gensym "memref-value-"))
			    (object-var (gensym "memref-object-")))
			`(let ((,value-var ,value) (,object-var ,object))
			   (with-inline-assembly (:returns :eax)
			     (:compile-two-forms (:untagged-fixnum-ecx :ebx) ,offset ,index)
			     (:load-lexical (:lexical-binding ,value-var) :eax)
			     ,@(when (cl:plusp (cl:- movitz::+movitz-fixnum-shift+ 2))
				     `((:sarl ,(cl:- movitz::+movitz-fixnum-shift+ 2)) :ebx))
			     (:addl :ebx :ecx) ; index += offset
			     (:load-lexical (:lexical-binding ,object-var) :ebx)
			     (:andl ,(mask-field (byte 14 2) -1) :eax)
			     (,prefixes :movw :ax (:ebx :ecx))))))))
		(:lisp
		 (let* ((localp (movitz:movitz-eval localp env))
			(prefixes (append prefixes
					  (if localp
					      nil
					      movitz:*compiler-nonlocal-lispval-write-segment-prefix*))))
		   (cond
		     ((and (movitz:movitz-constantp offset env)
			   (movitz:movitz-constantp index env))
		      `(with-inline-assembly (:returns :eax)
			 (:compile-two-forms (:eax :ebx) ,value ,object)
			 (,prefixes :movl :eax (:ebx ,(+ (movitz:movitz-eval offset env)
							 (* 4 (movitz:movitz-eval index env)))))))
		     ((movitz:movitz-constantp offset env)
		      (let ((value-var (gensym "memref-value-")))
			`(let ((,value-var ,value))
			   (with-inline-assembly (:returns :eax)
			     (:compile-two-forms (:ebx :ecx) ,object ,index)
			     (:load-lexical (:lexical-binding ,value-var) :eax)
			     ,@(when (plusp (- movitz:+movitz-fixnum-shift+ 2))
				     `((:sarl ,(- movitz:+movitz-fixnum-shift+ 2)) :ecx))
			     (,prefixes :movl :eax (:ebx :ecx ,(movitz:movitz-eval offset env)))))))
		     (t (let ((value-var (gensym "memref-value-"))
			      (object-var (gensym "memref-object-")))
			  `(let ((,value-var ,value) (,object-var ,object))
			     (with-inline-assembly (:returns :eax)
			       (:compile-two-forms (:untagged-fixnum-ecx :ebx) ,offset ,index)
			       (:load-lexical (:lexical-binding ,value-var) :eax)
			       ,@(when (cl:plusp (cl:- movitz::+movitz-fixnum-shift+ 2))
				       `((:sarl ,(cl:- movitz::+movitz-fixnum-shift+ 2)) :ebx))
			       (:addl :ebx :ecx) ; index += offset
			       (:load-lexical (:lexical-binding ,object-var) :ebx)
			       (,prefixes :movl :eax (:ebx :ecx)))))))))
		(:code-vector
		 (let ((prefixes (append prefixes
					 (if localp
					     nil
					     movitz:*compiler-nonlocal-lispval-write-segment-prefix*))))
		   (cond
		     ((and (movitz:movitz-constantp offset env)
			   (movitz:movitz-constantp index env))
		      `(with-inline-assembly (:returns :eax)
			 (:compile-two-forms (:eax :ebx) ,value ,object)
			 (:movl ,movitz:+code-vector-word-offset+
				(:ebx ,(+ (movitz:movitz-eval offset env)
					  (* 4 (movitz:movitz-eval index env)))))
			 (,prefixes
			  :addl :eax (:ebx ,(+ (movitz:movitz-eval offset env)
					       (* 4 (movitz:movitz-eval index env)))))))
		     ((movitz:movitz-constantp offset env)
		      (let ((value-var (gensym "memref-value-")))
			`(let ((,value-var ,value))
			   (with-inline-assembly (:returns :eax)
			     (:compile-two-forms (:ebx :ecx) ,object ,index)
			     (:load-lexical (:lexical-binding ,value-var) :eax)
			     ,@(when (plusp (- movitz:+movitz-fixnum-shift+ 2))
				     `((:sarl ,(- movitz:+movitz-fixnum-shift+ 2)) :ecx))
			     (:movl ,movitz:+code-vector-word-offset+
				    (:ebx :ecx ,(movitz:movitz-eval offset env)))
			     (,prefixes
			      :addl :eax (:ebx :ecx ,(movitz:movitz-eval offset env)))))))
		     (t (let ((value-var (gensym "memref-value-"))
			      (object-var (gensym "memref-object-")))
			  `(let ((,value-var ,value)
				 (,object-var ,object))
			     (with-inline-assembly (:returns :eax)
			       (:compile-two-forms (:untagged-fixnum-ecx :ebx) ,offset ,index)
			       (:load-lexical (:lexical-binding ,value-var) :eax)
			       ,@(when (cl:plusp (cl:- movitz::+movitz-fixnum-shift+ 2))
				       `((:sarl ,(cl:- movitz::+movitz-fixnum-shift+ 2)) :ebx))
			       (:addl :ebx :ecx) ; index += offset
			       (:load-lexical (:lexical-binding ,object-var) :ebx)
			       (:movl ,movitz:+code-vector-word-offset+ (:ebx :ecx))
			       (,prefixes :addl :eax (:ebx :ecx)))))))))
		(t ;; (warn "Can't handle inline MEMREF: ~S" form)
		 form))))))))

(defun (setf memref) (value object offset &key (index 0) (type :lisp) localp (endian :host) (physicalp nil))
  (case type
    (:lisp
     (assert (not physicalp))
     (if localp
	 (setf (memref object offset :index index :localp t) value)
	 (setf (memref object offset :index index :localp nil) value)))
    (:code-vector
     (assert (not physicalp))
     (if localp
	 (setf (memref object offset :index index :localp t :type :code-vector) value)
	 (setf (memref object offset :index index :localp nil :type :code-vector) value)))
    (t (macrolet ((do-memref (physicalp)
		    `(ecase type
		       (:character
			(setf (memref object offset :index index :type :character :physicalp ,physicalp)
			      value))
		       (:unsigned-byte8
			(setf (memref object offset :index index :type :unsigned-byte8 :physicalp ,physicalp)
			      value))
		       (:unsigned-byte16
			(ecase endian
			  ((:host :little)
			   (setf (memref object offset :index index :type :unsigned-byte16 :endian :little :physicalp ,physicalp)
				 value))
			  ((:big)
			   (setf (memref object offset :index index :type :unsigned-byte16 :endian :big :physicalp ,physicalp)
				 value))))
		       (:unsigned-byte32
			(setf (memref object offset :index index :type :unsigned-byte32 :physicalp ,physicalp)
			      value)))))
	 (if physicalp
	     (do-memref t)
	     (do-memref nil))))))


(define-compiler-macro memref-int
    (&whole form address &key (offset 0) (index 0) (type :unsigned-byte32) (physicalp t)
     &environment env)
  (if (or (not (movitz:movitz-constantp type env))
	  (not (movitz:movitz-constantp physicalp env)))
      form
    (let* ((physicalp (movitz::eval-form physicalp env))
	   (prefixes (if (not physicalp)
			 ()
		       movitz:*compiler-physical-segment-prefix*)))
      (ecase (movitz::movitz-eval type env)
	(:lisp
	 (let ((address-var (gensym "memref-int-address-")))
	   `(let ((,address-var ,address))
	      (with-inline-assembly (:returns :eax)
		(:compile-two-forms (:eax :ecx) ,offset ,index)
		(:load-lexical (:lexical-binding ,address-var) :ebx)
		(:shll 2 :ecx)
		(:addl :ebx :eax)
		(:into)
		(:testb ,(mask-field (byte (+ 2 movitz::+movitz-fixnum-shift+) 0) -1)
			:al)
		(:jnz '(:sub-program () (:int 63)))
		(:addl :eax :ecx)
		(:shrl ,movitz::+movitz-fixnum-shift+ :ecx) ; scale down address
		(,prefixes :movl (:ecx) :eax)))))
	(:unsigned-byte32
	 (cond
	   ((integerp index)
	    (let ((address-var (gensym "memref-int-address-")))
	      `(let ((,address-var (+ ,address ,offset)))
		 (with-inline-assembly (:returns :untagged-fixnum-ecx)
		   (:compile-form (:result-mode :untagged-fixnum-ecx) ,address-var)
		   (,prefixes :movl (:ecx ,index) :ecx)))))
	   (t (let ((address-var (gensym "memref-int-address-"))
		    (index-var (gensym "memref-int-index-")))
		`(let ((,address-var (+ ,address ,offset))
		       (,index-var ,index))
		   (with-inline-assembly (:returns :untagged-fixnum-ecx)
		     (:compile-two-forms (:eax :untagged-fixnum-ecx) ,index-var ,address-var)
		     (:testb ,movitz:+movitz-fixnum-zmask+ :al)
		     (:jnz '(:sub-program () (:int 64)))
		     (,prefixes :movl (:ecx :eax) :ecx)))))))
	(:unsigned-byte8
	 (cond
	  ((and (eq 0 offset) (eq 0 index))
	   `(with-inline-assembly (:returns :untagged-fixnum-ecx
					    :type (unsigned-byte 8))
	      (:compile-form (:result-mode :untagged-fixnum-ecx) ,address)
	      (,prefixes :movzxb (:ecx) :ecx)))
	  (t (let ((address-var (gensym "memref-int-address-")))
	       `(let ((,address-var ,address))
		  (with-inline-assembly (:returns :untagged-fixnum-ecx
						  :type (unsigned-byte 8))
		    (:compile-two-forms (:eax :ecx) ,offset ,index)
		    (:load-lexical (:lexical-binding ,address-var) :ebx)
		    (:addl :eax :ecx)
		    (:addl :ebx :ecx)
		    (:shrl ,movitz::+movitz-fixnum-shift+ :ecx) ; scale down address
		    (,prefixes :movzxb (:ecx) :ecx)))))))
	(:signed-byte8
	 (cond
	  ((and (eq 0 offset) (eq 0 index))
	   `(with-inline-assembly (:returns :ecx :type (signed-byte 8))
	      (:compile-form (:result-mode :untagged-fixnum-ecx) ,address)
	      (,prefixes :movsxb (:ecx) :ecx)
	      (:shll ,movitz:+movitz-fixnum-shift+ :ecx)))
	  (t (let ((address-var (gensym "memref-int-address-")))
	       `(let ((,address-var ,address))
		  (with-inline-assembly (:returns :ecx :type (signed-byte 8))
		    (:compile-two-forms (:eax :ecx) ,offset ,index)
		    (:load-lexical (:lexical-binding ,address-var) :ebx)
		    (:addl :eax :ecx)
		    (:addl :ebx :ecx)
		    (:shrl ,movitz::+movitz-fixnum-shift+ :ecx) ; scale down address
		    (,prefixes :movsxb (:ecx) :ecx)
		    (:shll ,movitz:+movitz-fixnum-shift+ :ecx)))))))
	(:unsigned-byte16
	 (cond
	  ((and (eq 0 offset) (eq 0 index))
	   `(with-inline-assembly (:returns :untagged-fixnum-ecx
					    :type (unsigned-byte 16))
	      (:compile-form (:result-mode :untagged-fixnum-ecx) ,address)
	      (,prefixes :movzxw (:ecx) :ecx)))
	  (t (let ((address-var (gensym "memref-int-address-")))
	       `(let ((,address-var ,address))
		  (with-inline-assembly (:returns :untagged-fixnum-ecx
						  :type (unsigned-byte 16))
		    (:compile-two-forms (:eax :ecx) ,offset ,index)
		    (:load-lexical (:lexical-binding ,address-var) :ebx)
		    (:shll 1 :ecx)	; scale index
		    (:addl :eax :ecx)
		    (:addl :ebx :ecx)
		    (:shrl ,movitz::+movitz-fixnum-shift+ :ecx) ; scale down address
		    (,prefixes :movzxw (:ecx) :ecx)))))))))))

(defun memref-int (address &key (offset 0) (index 0) (type :unsigned-byte32) (physicalp t))
  (cond
   (physicalp
    (ecase type
      (:lisp
       (memref-int address :offset offset :index index))
      (:unsigned-byte8
       (memref-int address :offset offset :index index :type :unsigned-byte8))
      (:unsigned-byte16
       (memref-int address :offset offset :index index :type :unsigned-byte16))
      (:unsigned-byte32
       (memref-int address :offset offset :index index))))
   ((not physicalp)
    (ecase type
      (:lisp
       (memref-int address :offset offset :index index :physicalp nil))
      (:unsigned-byte8
       (memref-int address :offset offset :index index :type :unsigned-byte8 :physicalp nil))
      (:unsigned-byte16
       (memref-int address :offset offset :index index :type :unsigned-byte16 :physicalp nil))
      (:unsigned-byte32
       (memref-int address :offset offset :index index :physicalp nil))))))

(define-compiler-macro (setf memref-int)
    (&whole form value address &key (offset 0) (index 0) (type :type) (physicalp t)
	    &environment env)
  (if (or (not (movitz:movitz-constantp type env))
	  (not (movitz:movitz-constantp physicalp env)))
      (progn
	(warn "setf memref-int form: ~S, ~S ~S" form type physicalp)
	form)
      (let* ((physicalp (movitz::eval-form physicalp env))
	     (prefixes (if (not physicalp)
			   ()
			   movitz:*compiler-physical-segment-prefix*)))
	(ecase type
	  (:unsigned-byte32
	   (assert (= 4 movitz:+movitz-fixnum-factor+))
	   (cond
	     ((movitz:movitz-constantp offset env)
	      (let ((offset (movitz:movitz-eval offset env))
		    (addr-var (gensym "memref-int-address-"))
		    (value-var (gensym "memref-int-value-")))
		`(let ((,value-var ,value)
		       (,addr-var (+ ,address ,index)))
		   (with-inline-assembly (:returns :untagged-fixnum-ecx)
		     (:compile-form (:result-mode :untagged-fixnum-ecx) ,addr-var)
		     (:testb ,movitz:+movitz-fixnum-zmask+
			     :cl)
		     (:jnz '(:sub-program () (:int 70)))
		     (:pushl :ecx) ; an untagged integer (zerop (mod x 4)) is still GC-safe.
		     (:compile-form (:result-mode :untagged-fixnum-ecx) ,value-var)
		     (:popl :eax)
		     (,prefixes :movl :ecx (:eax ,offset))))))
	     (t (let ((offset-var (gensym "memref-int-offset-"))
		      (addr-var (gensym "memref-int-address-"))
		      (value-var (gensym "memref-int-value-")))
		  `(let ((,offset-var ,offset)
			 (,value-var ,value)
			 (,addr-var (+ ,address ,offset ,index)))
		     (with-inline-assembly (:returns :untagged-fixnum-ecx)
		       (:compile-form (:result-mode :untagged-fixnum-ecx) ,addr-var)
		       (:testb ,movitz:+movitz-fixnum-zmask+
			       :cl)
		       (:jnz '(:sub-program () (:int 70)))
		       (:pushl :ecx) ; an untagged integer (zerop (mod x 4)) is still GC-safe.
		       (:compile-form (:result-mode :untagged-fixnum-ecx) ,value-var)
		       (:popl :eax)
		       (:compile-form (:result-mode :edx) ,offset-var)
		       (:std)
		       (:shrl ,movitz:+movitz-fixnum-shift+ :edx)
		       (,prefixes :movl :ecx (:eax :edx))
		       (:movl :edi :edx) ; make EDX GC-safe
		       (:cld)))))))
	  (:lisp
	   (assert (= 4 movitz:+movitz-fixnum-factor+))
	   `(with-inline-assembly (:returns :eax)
	      (:compile-form (:result-mode :push) ,address)
	      (:compile-form (:result-mode :push) ,index)
	      (:compile-form (:result-mode :push) ,offset)
	      (:compile-form (:result-mode :eax) ,value)
	      (:popl :edx)		; offset
	      (:popl :ebx)		; index
	      (:popl :ecx)		; address
	      (:addl :edx :ecx)
	      (:shrl ,movitz::+movitz-fixnum-shift+ :ecx)
	      (,prefixes :movl :eax (:ecx :ebx))))
	  (:unsigned-byte8
	   (let ((address-var (gensym "memref-int-address-"))
		 (index-var (gensym "memref-int-index-var-"))
		 (offset-var (gensym "memref-int-offset-var-"))
		 (value-var (gensym "memref-int-value-var-")))
	     `(let ((,value-var ,value)
		    (,address-var ,address)
		    (,offset-var (+ ,index ,offset)))
		(with-inline-assembly (:returns :nothing)
		  (:load-lexical (:lexical-binding ,address-var) :ecx)
		  (:load-lexical (:lexical-binding ,offset-var) :edx)
		  (:load-lexical (:lexical-binding ,value-var) :eax)
		  (:shll ,(- 8 movitz::+movitz-fixnum-shift+) :eax)
		  (:addl :edx :ecx)
		  (:shrl ,movitz::+movitz-fixnum-shift+ :ecx)
		  (,prefixes :movb :ah (:ecx)))
		,value-var)))
	  (:unsigned-byte16
	   (cond
	     ((eq 0 offset)
	      (let ((address-var (gensym "memref-int-address-"))
		    (index-var (gensym "memref-index-var-"))
		    (value-var (gensym "memref-value-var-")))
		`(let ((,value-var ,value)
		       (,address-var ,address)
		       (,index-var ,index))
		   (with-inline-assembly (:returns :eax)
		     (:load-lexical (:lexical-binding ,value-var) :eax) ; value
		     (:load-lexical (:lexical-binding ,index-var) :ebx) ; index
		     (:load-lexical (:lexical-binding ,address-var) :ecx) ; address
		     (:shll 1 :ebx)	; scale index
		     (:addl :ebx :ecx)
		     (:shrl ,movitz:+movitz-fixnum-shift+ :ecx) ; scale address
		     (:std)
		     (:shrl ,movitz:+movitz-fixnum-shift+ :eax) ; scale value
		     (,prefixes :movw :ax (:ecx))
		     (:leal ((:eax ,movitz:+movitz-fixnum-factor+)) :eax)
		     (:cld)))))
	     (t (let ((address-var (gensym "memref-int-address-"))
		      (offset-var (gensym "memref-offset-var-"))
		      (index-var (gensym "memref-index-var-"))
		      (value-var (gensym "memref-value-var-")))
		  `(let ((,value-var ,value)
			 (,address-var ,address)
			 (,offset-var ,offset)
			 (,index-var ,index))
		     (with-inline-assembly (:returns :eax)
		       (:load-lexical (:lexical-binding ,address-var) :ecx)
		       (:load-lexical (:lexical-binding ,index-var) :ebx)
		       (:load-lexical (:lexical-binding ,offset-var) :edx)
		       (:load-lexical (:lexical-binding ,value-var) :eax)
		       (:leal (:ecx (:ebx 2)) :ecx)
		       (:addl :edx :ecx)			;
		       (:shrl ,movitz::+movitz-fixnum-shift+ :eax) ; scale value
		       (:std)
		       (:shrl ,movitz::+movitz-fixnum-shift+ :ecx) ; scale offset+address
		       (,prefixes :movw :ax (:ecx))
		       (:leal ((:eax ,movitz:+movitz-fixnum-factor+)) :eax)
		       (:cld)))))))))))

(defun (setf memref-int)
    (value address &key (offset 0) (index 0) (type :unsigned-byte32) (physicalp t))
  (cond
    (physicalp
     (ecase type
       (:unsigned-byte8
        (setf (memref-int address :offset offset :index index :type :unsigned-byte8)
              value))
       (:unsigned-byte16
        (setf (memref-int address :offset offset :index index :type :unsigned-byte16)
              value))
       (:unsigned-byte32
        (setf (memref-int address :offset offset :index index :type :unsigned-byte32)
              value))))
    ((not physicalp)
     (ecase type
       (:unsigned-byte8
        (setf (memref-int address :offset offset :index index :type :unsigned-byte8 :physicalp nil)
              value))
       (:unsigned-byte16
        (setf (memref-int address :offset offset :index index :type :unsigned-byte16 :physicalp nil)
              value))
       (:unsigned-byte32
        (setf (memref-int address :offset offset :index index :type :unsigned-byte32 :physicalp nil)
              value))))))

(defun memcopy (object-1 object-2 offset index-1 index-2 count type)
  (ecase type
    ((:unsigned-byte8 :character)
     (with-inline-assembly (:returns :nothing)
       (:compile-form (:result-mode :edx) offset)
       (:compile-form (:result-mode :ecx) index-1)
       (:addl :edx :ecx)
       (:compile-form (:result-mode :eax) object-1)
       (:sarl #.movitz::+movitz-fixnum-shift+ :ecx)
       (:addl :ecx :eax)

       (:compile-form (:result-mode :ecx) index-2)
       (:addl :edx :ecx)
       (:compile-form (:result-mode :ebx) object-2)
       (:sarl #.movitz::+movitz-fixnum-shift+ :ecx)
       (:addl :ecx :ebx)

       (:compile-form (:result-mode :ecx) count)
       (:shrl #.movitz::+movitz-fixnum-shift+ :ecx)
       (:jz 'done)
       (:decl :eax)
       (:decl :ebx)
       loop
       (:movb (:ebx :ecx) :dl)
       (:movb :dl (:eax :ecx))
       (:decl :ecx)
       (:jnz 'loop)
       done))))
	     
(define-compiler-macro %copy-words (destination source count &optional (start1 0) (start2 0)
				    &environment env)
  (assert (= 4 movitz::+movitz-fixnum-factor+))
  (cond
   ((and (movitz:movitz-constantp start1 env)
	 (movitz:movitz-constantp start2 env))
    (let ((start1 (movitz::eval-form start1 env))
	  (start2 (movitz::eval-form start2 env)))
      `(with-inline-assembly-case ()
	 (do-case (t :eax :labels (done copy-loop no-fixnum))
	   (:compile-arglist () ,destination ,source ,count)
	   (:popl :edx)			; count
	   ,@(unless (= 0 start1)
	       `((:addl ,(* start1 movitz::+movitz-fixnum-factor+) :eax)))
	   (:testl :edx :edx)
	   (:jz 'done)
	   ,@(unless (= 0 start2)
	       `((:addl ,(* start2 movitz::+movitz-fixnum-factor+) :ebx)))
	   (:testb ,movitz::+movitz-fixnum-zmask+ :dl)
	   (:jnz '(:sub-program ()
		   (:movl :edx :eax)
		   (:int 64)))
	  copy-loop
	   (:movl (:ebx :edx) :ecx)
	   (:movl :ecx (:eax :edx))
	   (:subl 4 :edx)
	   (:jnz 'copy-loop)
	  done))))
   (t `(with-inline-assembly-case ()
	 (do-case (t :eax :labels (done copy-loop no-fixnum))
	   (:compile-arglist () ,destination ,source ,count ,start1 ,start2)
	   (:popl :ecx)			; start2
	   (:addl :ecx :ebx)
	   (:popl :ecx)			; start1
	   (:addl :ecx :eax)
	   (:popl :edx)			; count
	   (:testl :edx :edx)
	   (:jz 'done)
	   (:testb ,movitz::+movitz-fixnum-zmask+ :dl)
	   (:jnz '(:sub-program ()
		   (:movl :edx :eax)
		   (:int 64)))
	  copy-loop
	   (:movl (:ebx :edx) :ecx)
	   (:movl :ecx (:eax :edx))
	   (:subl 4 :edx)
	   (:jnz 'copy-loop)
	  done)))))

(defun %copy-words (destination source count &optional (start1 0) (start2 0))
  (%copy-words destination source count start1 start2))

;; (define-compiler-macro memrange (object ))

